<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>UPPAAL Documentation</title><link>/</link><description>Recent content on UPPAAL Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>Basic Test Generation</title><link>/gui-reference/yggdrasil/tutorial/basic-test-generation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/yggdrasil/tutorial/basic-test-generation/</guid><description>Create the models Open the On/Off System model &amp;ldquo;onoff/onoff.xml&amp;rdquo; file in Uppaal. The system contains two templates entitled System and User. The System represents the system or device (e.g. lamp) under test. The User models the possible user interactions with the system.
The system can be either On or Off, with channels on and off changing between them. The user can non-deterministically press on or off.
System template User template Add Test Cases specific model annotations First, some Test Cases specific declarations muse be made; these are required for the generator to use depth-first reachability and single step techniques for test-case generation.</description></item><item><title>File Menu</title><link>/gui-reference/menu-bar/file/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/menu-bar/file/</guid><description>The leftmost menu of the menu bar is the file menu. It is mainly used to open and save (part of) system descriptions or requirement specifications created in UPPAAL. The available items are:
New System: re-initiates the editor with an empty system. Open System: loads an existing system from file. The corresponding requirement specification (i.e. same file name but with the suffix .q) is loaded into the verifier, if it exists.</description></item><item><title>Generating Traces</title><link>/gui-reference/yggdrasil/traces/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/yggdrasil/traces/</guid><description>Traces are generated using three purposes: queries, depth search, and individual edges.
In the Verifier tab the existential queries (E&amp;lt;&amp;gt;) can be used to specify a desired functionality to be tested and hence can be selected as a test purpose for test case generation. All or specific queries can be selected and the resulting trace is added to be used as a test case.
The second option uses heuristics of random depth first search of the specified number of steps with a hope of increasing the coverage.</description></item><item><title>Identifiers</title><link>/language-reference/expressions/identifiers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/language-reference/expressions/identifiers/</guid><description>The valid identifier names are described by the following regular expression: [a-zA-Z_]([a-zA-Z0-9_])*
Examples a, B, c2, d2 valid identifier names. 1, 2a, 3B, 4c5 invalid identifier names.</description></item><item><title>Locations</title><link>/language-reference/system-description/templates/locations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/language-reference/system-description/templates/locations/</guid><description>Locations of a timed automaton are graphically represented as circles. If a timed automaton is considered as a directed graph, then locations represent the vertices of this graph. Locations are connected by edges.
Names Locations can have an optional name. Besides serving as an identifier allowing you to refer to the location from the requirement specification language, named locations are useful when documenting the model. The name must be a valid identifier and location names share the name space with variables, types, templates, etc.</description></item><item><title>Navigation Tree</title><link>/gui-reference/system-editor/navigation-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/system-editor/navigation-tree/</guid><description>The navigation tree is shown in the left panel of the system editor. It is used for accessing the various components of a system description. A node in the tree can be double clicked to view (or hide) the sub tree of the node. The root of the navigation tree is named Project.
The sub node Declarations is used for declarations of global scope. They can be referred to directly in template declarations.</description></item><item><title>Semantics of the Symbolic Queries</title><link>/language-reference/requirements-specification/symb_queries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/language-reference/requirements-specification/symb_queries/</guid><description>In the following we give a pseudo-formal semantics for the requirement specification language of UPPAAL. We assume the existence of a timed transition system (S, s0, →) as defined in the semantics of UPPAAL timed automata. In the following, p and q are state properties for which we define the following temporal properties:
Possibly The property E&amp;lt;&amp;gt; p evaluates to true for a timed transition system if and only if there is a sequence of delay and action transitions s0 → s1 → &amp;hellip; → sn, where s0 is the initial state and sn satisfies p.</description></item><item><title>Simulation Control</title><link>/gui-reference/concrete-simulator/simulation-control/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/concrete-simulator/simulation-control/</guid><description>The simulation control is the left panel of the simulator. It is used to control the simulation and to select the state or transition to be visualized in the others panels of the simulator. The control panel is divided in two parts:
The upper part is used for performing step-by-step simulation. The Transition chooser area is a clickable area where vertical axis displays the active transitions at this location and horizontal axis displays the time at which the transition will be ﬁred.</description></item><item><title>Specifying Requirements</title><link>/gui-reference/verifier/specifying/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/verifier/specifying/</guid><description>An overview of the system requirements (called queries below and in the GUI) is shown in the panel named Overview of the verifier. The toggle button Comments/Queries is used to control if the queries or the comments are to be shown in the overview.
Queries are selected and de-selected using the mouse alone, or in combination with the Shift or the Control key of the keyboard (use the Shift key to (de-)select a range of entries and the Control key to (de-)select single entries).</description></item><item><title>Template Instantiation</title><link>/language-reference/system-description/system-definition/template-instantiation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/language-reference/system-description/system-definition/template-instantiation/</guid><description>New templates can be defined from existing templates using the grammar for Instantiation. The new template has the same automaton structure and the same local variables as the template it is defined from. However, arguments are provided for any formal parameters of the template, thus changing the interface of the template.
Instantiation ::= ID [ &amp;#39;(&amp;#39; [Parameters] &amp;#39;)&amp;#39; ] &amp;#39;=&amp;#39; ID &amp;#39;(&amp;#39; [Arguments] &amp;#39;)&amp;#39; &amp;#39;;&amp;#39; Template instantiation is most often used to bind formal parameters to actual arguments.</description></item><item><title>Types</title><link>/language-reference/system-description/declarations/types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/language-reference/system-description/declarations/types/</guid><description>There are 6 predefined types: int, bool, clock, chan, double and string. Array and record types can be defined over all types except string.
Type ::= Prefix TypeId Prefix ::= &amp;#39;urgent&amp;#39; | &amp;#39;broadcast&amp;#39; | &amp;#39;meta&amp;#39; | &amp;#39;const&amp;#39; TypeId ::= ID | &amp;#39;int&amp;#39; | &amp;#39;clock&amp;#39; | &amp;#39;chan&amp;#39; | &amp;#39;bool&amp;#39; | &amp;#39;double&amp;#39; | &amp;#39;string&amp;#39; | &amp;#39;int&amp;#39; &amp;#39;[&amp;#39; [Expression] &amp;#39;,&amp;#39; [Expression] &amp;#39;]&amp;#39; | &amp;#39;scalar&amp;#39; &amp;#39;[&amp;#39; Expression &amp;#39;]&amp;#39; | &amp;#39;struct&amp;#39; &amp;#39;{&amp;#39; FieldDecl (FieldDecl)* &amp;#39;}&amp;#39; FieldDecl ::= Type ID ArrayDecl* (&amp;#39;,&amp;#39; ID ArrayDecl*)* &amp;#39;;&amp;#39; ArrayDecl ::= &amp;#39;[&amp;#39; [Expression] &amp;#39;]&amp;#39; | &amp;#39;[&amp;#39; Type &amp;#39;]&amp;#39; The default range of an integer is [-32768, 32767].</description></item><item><title>UPPAAL</title><link>/toolsandapi/uppaal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/toolsandapi/uppaal/</guid><description>UPPAAL can be executed from the command line using the following command on unix:
uppaal [OPTION] &amp;hellip; [FILENAME]
On windows, the following command can be used (for instance, using &amp;ldquo;Run&amp;rdquo; from the Start Menu):
java -jar \path\uppaal.jar [OPTION] &amp;hellip; [FILENAME]
where path is the complete path to the uppaal.jar file (it might also be necessary to specify the complete path to the java executable).
The optional filename refers to a model to be loaded at startup.</description></item><item><title>Using Model Variables</title><link>/gui-reference/yggdrasil/tutorial/using-variables/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/yggdrasil/tutorial/using-variables/</guid><description>This tutorial assumes you have understood basic test case generation.
The model: Up/Down system Open the updown/updown.xml file in Uppaal.
The system contains two templates: System and User.
The system can be either On, Max, or Off, with channels up and down changing between them. The user can non-deterministically press up or down.
System template User template Add model annotations and test pre- and post-fix code Global variable declarations and prefix/postfix code is the same as for the on/off model.</description></item><item><title>Using Queries</title><link>/gui-reference/yggdrasil/tutorial/using-queries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/yggdrasil/tutorial/using-queries/</guid><description>This tutorial assumes you have understood using variables.
The system model This tutorial uses the same Up/Down model as in the section using variables. Open the updown/updown.xml file in Uppaal.
Editing the Queries Sometimes it is desirable to generate test cases for specific purposes. This can be done by creating a verification query for the purpose, and use that to generate a test trace.
In the Verifier tab you can enter queries.</description></item><item><title>Drawing</title><link>/gui-reference/system-editor/drawing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/system-editor/drawing/</guid><description>The rightmost panel of the system editor is used for drawing automata. There are currently four drawing tools named Select, Location, Edge, and Nail represented by the buttons in the tool bar.
Select tool: The select tool is used to select, move, modify and delete elements. Elements can be selected by clicking on them or by dragging a rubber band arround one or more elements. Elements can be added or removed from a selection by holding down the control key while clicking on the element.</description></item><item><title>Edges</title><link>/language-reference/system-description/templates/edges/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/language-reference/system-description/templates/edges/</guid><description>Locations are connected by edges. Edges are annotated with selections, guards, synchronisations and updates. Edges may also have branches of possible destinations with their own updates and probabilistic weights.
Selections Selections non-deterministically bind a given identifier to a value in a given range. The other three labels of an edge are within the scope of this binding. Guards An edge is enabled in a state if and only if the guard evaluates to true.</description></item><item><title>Edit Menu</title><link>/gui-reference/menu-bar/edit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/menu-bar/edit/</guid><description>The Edit menu offers a set of commands supported in the system editor. The items are:
Undo: reverses the most recent editing action. This function is only available in the editor. Redo: re-applies the editing action that has most recently been reversed by the Undo action. This function is only available in the editor. Cut: removes the selected text and places it in the clipboard. There must be an active text selection.</description></item><item><title>Functions</title><link>/language-reference/system-description/declarations/functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/language-reference/system-description/declarations/functions/</guid><description>Functions can be declared alongside other declarations. The syntax for functions is defined by the grammar for Function:
Function ::= [Type] [ID] &amp;#39;(&amp;#39; [Parameters] &amp;#39;)&amp;#39; Block Block ::= &amp;#39;{&amp;#39; LocalDeclaration* Statement* &amp;#39;}&amp;#39; LocalDeclation ::= TypeDeclaration | VariableDeclaration Statement ::= Block | &amp;#39;;&amp;#39; | [Expression] &amp;#39;;&amp;#39; | ForLoop | Iteration | WhileLoop | DoWhileLoop | IfStatement | ReturnStatement ForLoop ::= &amp;#39;for&amp;#39; &amp;#39;(&amp;#39; [Expression] &amp;#39;;&amp;#39; [Expression] &amp;#39;;&amp;#39; [Expression] &amp;#39;)&amp;#39; Statement Iteration ::= &amp;#39;for&amp;#39; &amp;#39;(&amp;#39; [ID] &amp;#39;:&amp;#39; [Type] &amp;#39;)&amp;#39; Statement WhileLoop ::= &amp;#39;while&amp;#39; &amp;#39;(&amp;#39; [Expression] &amp;#39;)&amp;#39; Statement DoWhile ::= &amp;#39;do&amp;#39; Statement &amp;#39;while&amp;#39; &amp;#39;(&amp;#39; [Expression] &amp;#39;)&amp;#39; &amp;#39;;&amp;#39; IfStatment ::= &amp;#39;if&amp;#39; &amp;#39;(&amp;#39; [Expression] &amp;#39;)&amp;#39; Statement [ &amp;#39;else&amp;#39; Statement ] ReturnStatement ::= &amp;#39;return&amp;#39; [ [Expression] ] &amp;#39;;&amp;#39; Functions The declarations inside functions include only variable and type declarations.</description></item><item><title>Progress Measures</title><link>/language-reference/system-description/system-definition/progress-measures/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/language-reference/system-description/system-definition/progress-measures/</guid><description>A progress measure is an expression that defines progress in the model. It should be weakly monotonically increasing, although occasional decreasses are acceptable. E.g. sequence numbers used in communication protocols might be used to define a progress measure, provided that the sequence number does not overflow to often.
If progress measures are defined, UPPAAL uses the generalized sweepline method to reduce the memory usage. However to be efficient, the domain of a progress measure should not be too large - otherwise performance might degrade significantly.</description></item><item><title>Specifying Test Code</title><link>/gui-reference/yggdrasil/test-code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/yggdrasil/test-code/</guid><description>Traces are translated into executable test cases based on test code entered into the model. The test code is entered as verbatim text, so any language or execution back-end can be used. Test code can be entered in five areas: Prefix code, location enter code, location exit code, edge code, and postfix code. Each test case starts with the prefix code, continues with test code along the locations and edges of the trace and ends with the postfix code.</description></item><item><title>Tool Bar</title><link>/gui-reference/toolbar/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/toolbar/</guid><description>The tool bar is normally located just below the menu bar but can be moved (using the mouse) to other positions or even to a separate window. The tool bar is divided into four groups. The three leftmost groups provide quick access to some of the most frequently used menu items. The rightmost group contains editing tools.
The first group contains the following buttons: New, Open Project, and Save. These features are described in the File menu section.</description></item><item><title>Variables Panel</title><link>/gui-reference/concrete-simulator/variables/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/concrete-simulator/variables/</guid><description>The variables panel is the middle panel of the simulator. It displays the values of the data and clock variables in the current state or transition selected in the trace of the simulation control panel.</description></item><item><title>Verifying Requirements</title><link>/gui-reference/verifier/verifying/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/verifier/verifying/</guid><description>The queries (i.e. the system requirements) are verified from the verifier interface of UPPAAL. A verification is always performed according to the settings specified in the Options menu of the main menu bar.
The selected queries are verified when the button named Check is pressed. The verification progress dialog displays the progress of how many queries have been verified, what is the current load of a passed-waiting list, current processor time usage (the time spent for verification is in blue, the time spent by operating system is in red), current usage of host&amp;rsquo;s random access memory (verification memory is in blue, memory used by other running processes is in gray and operating system cache and buffers are in yellow), swap disk usage (swapped out verification is in blue, other is in grey).</description></item><item><title>verifyta</title><link>/toolsandapi/verifyta/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/toolsandapi/verifyta/</guid><description>The verifier functionality is accessible through verifyta command line utility in bin-Windows or bin-Linux directory of the distribution. The supported options are displayed when running verifyta -h.</description></item><item><title>Declarations</title><link>/gui-reference/system-editor/declarations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/system-editor/declarations/</guid><description>Types, constants, variables and functions can be defined in the global scope by placing them in the global section labelled Declarations or System declarations, or locally for a template by placing in the Declarations section of a template.
Processes are instantiated by placing a process assignments in the System declarations section.
Finally, the system is defined as a parallel composition of a number of processes by placing a system declaration in the System declarations section.</description></item><item><title>External Functions</title><link>/language-reference/system-description/declarations/external-functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/language-reference/system-description/declarations/external-functions/</guid><description>External Functions is an expert user feature and requires a high-level understanding of dynamic library loading and linking. The feature is only officially supported on Linux.
This feature is supported since Uppaal Stratego version 4.1.20-7, or Uppaal version 5.0 or later.
External Functions can be decreated alongside other declaratios. External functions are local to the current scope, defined by the grammar:
ExternDecl = &amp;#39;import&amp;#39; String &amp;#39;{&amp;#39; [FwdDeclList] &amp;#39;}&amp;#39; FwdDeclList = FwdDecl &amp;#39;;&amp;#39; | FwdDeclList FwdDecl &amp;#39;;&amp;#39; FwdDecl = [ID &amp;#39;=&amp;#39;] Type ID &amp;#39;(&amp;#39; [Parameters] &amp;#39;)&amp;#39; The following code will load the external libary libexternal.</description></item><item><title>Gantt Chart</title><link>/language-reference/system-description/system-definition/gantt-chart/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/language-reference/system-description/system-definition/gantt-chart/</guid><description>A Gantt chart, commonly used in project management, is a bar chart that shows activities displayed against time. On the left of the chart is a list of the activities and along the top is a suitable time scale. Each activity is represented by a bar; the position and length of the bar reflect the start date, duration and end date of the activity.
In UPPAAL Gantt Charts are used to automatic visualize traces.</description></item><item><title>Java API</title><link>/toolsandapi/javaapi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/toolsandapi/javaapi/</guid><description>UPPAAL models can be created, loaded, saved, simulated and checked using libs/model.jar library. There is also javadoc included libs/model-javadoc.jar.
A demonstrating example is included in the demo/ModelDemo.java file.</description></item><item><title>Parameters</title><link>/language-reference/system-description/parameters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/language-reference/system-description/parameters/</guid><description>Templates and functions are parameterised. The syntax for parameters is defined by the grammar for Parameters:
Parameters ::= [ Parameter (&amp;#39;,&amp;#39; Parameter)* ] Parameter ::= [Type] [ &amp;#39;&amp;amp;&amp;#39; ] [ID] [ArrayDecl]* In contrast to global and local declarations, the parameter list should not be terminated by a semicolon.
Call by Reference and Call by Value Parameters can be declared to have either call-by-value or call-by-reference semantics. The syntax is taken from C++, where the identifier of a call-by-reference parameter is prefixed with an ampersand in the parameter declaration.</description></item><item><title>Process Panel</title><link>/gui-reference/concrete-simulator/process/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/concrete-simulator/process/</guid><description>The process panel is the rightmost upper panel of the simulator. It displays the process instances of the system descriptions. A red token marks the current control point of each automaton. One or more of the automata edges may also be red to indicate the transition currently selected in the simulation control panel.
Clicking inside a process box with the right mouse button opens a pop-up menu with the following items:</description></item><item><title>Semantics of the Statistical Queries</title><link>/language-reference/requirements-specification/smc_queries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/language-reference/requirements-specification/smc_queries/</guid><description>UPPAAL can estimate the probability of expression values statistically. There are four types of statistical properties: quantitative, qualitative, comparison and probable value estimation.
Simulation &amp;lsquo;simulate&amp;rsquo; &amp;lsquo;[&amp;rsquo; SMCBounds &amp;lsquo;]&amp;rsquo; &amp;lsquo;{&amp;rsquo; List &amp;lsquo;}&amp;rsquo; [ &amp;lsquo;:&amp;rsquo; [ SATRUNS &amp;lsquo;:&amp;rsquo; ] Expression ]
The simulation query collects the valuation of the specified list of expressions over the time, cost or action-transitions of the simulated run. The simulation runs can be filtered by a state expression after the colon (&amp;rsquo;:&amp;rsquo;) and the number of satisfying runs can be limited by positive integer using SMCBounds and SATRUNS.</description></item><item><title>Simulation Control</title><link>/gui-reference/symbolic-simulator/simulation-control/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/symbolic-simulator/simulation-control/</guid><description>The simulation control is the left panel of the simulator. It is used to control the simulation and to select the (symbolic) state or transition to be visualized in the other two panels of the simulator. The control panel is divided in two parts:
The upper part is used for performing step-by-step simulation. A list view displays the enabled transitions, with the currently selected transition highlighted. Pressing the Next-button causes the simulated system to take the selected transition.</description></item><item><title>Variables Panel</title><link>/gui-reference/symbolic-simulator/variables/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/symbolic-simulator/variables/</guid><description>The variables panel is the middle panel of the simulator. It displays the values of the data and clock variables in the current state or transition selected in the trace of the simulation control panel.
The data variable values are always shown as integers. The clock values are shown symbolically as a conjunction of clock guards of lower and upper bounds on individual clocks or differences between pairs of clocks (see Expressions section for more information on clock guards).</description></item><item><title>View Menu</title><link>/gui-reference/menu-bar/view/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/menu-bar/view/</guid><description>The view menu is used to modify the appearance of the system currently shown in the system editor and the simulator. The items are:
Zoom: shows a sub menu with fixed zoom values, zoom to fit, and itemes for zooming in, out, or to normal size. A change in the zoom value affects the templates the editor or the processes in the simulator (if one of the tools is active).</description></item><item><title>CI Estimation</title><link>/language-reference/requirements-specification/ci_estimation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/language-reference/requirements-specification/ci_estimation/</guid><description>Probability estimation query Pr[&amp;hellip;](&amp;lt;&amp;gt; q) yields a confidence interval (CI) for the probability of the state expression q being true with the confidence level of 1-α. For example, it could be [0.45, 0.55] (95% CI), or could be written as 0.5 ± 0.05 (95% CI), where ε=0.05 and α=0.05.
The frequentist interpretation of CI is that there exists a true probability that the state expression q is true and it is included in that confidence interval, but there is a risk α of making an error (the true probability being outside the confidence interval).</description></item><item><title>Message Sequence Chart</title><link>/gui-reference/concrete-simulator/sequence-chart/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/concrete-simulator/sequence-chart/</guid><description>The Message Sequence Chart (MSC) panel is the lower rightmost panel of the simulator. It displays an MSC view of the generated trace (also displayed in the simulation control panel of the simulator).
In the MSC view there is a vertical line for each process, and a horizontal line for each synchronisation point. The process name of each vertical line is indicated in the upper part of the MSC panel. The node names shown on the vertical lines indicate the control location of the automaton.</description></item><item><title>Process Panel</title><link>/gui-reference/symbolic-simulator/process/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/symbolic-simulator/process/</guid><description>The process panel is the rightmost upper panel of the simulator. It displays the process instances of the system descriptions. A red token marks the current control point of each automaton. One or more of the automata edges may also be red to indicate the transition currently selected in the simulation control panel.
Clicking inside a process box with the right mouse button opens a pop-up menu with the following items:</description></item><item><title>Reserved Keywords</title><link>/language-reference/reserved-keywords/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/language-reference/reserved-keywords/</guid><description>The reserved keywords that should not be used as identifier names when defining systems are: chan, clock, double, bool, int, commit, const, urgent, broadcast, init, process, state, invariant, location, guard, sync, assign, system, trans, deadlock, and, or, not, imply, true, false, for, forall, exists, while, do, if, else, return, typedef, struct, rate, before_update, after_update, meta, priority, progress, scalar, select, void, default, string.
The following keywords are reserved for future use: switch, case, continue, break, enum.</description></item><item><title>Socketserver</title><link>/toolsandapi/socketserver/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/toolsandapi/socketserver/</guid><description>To start a remote server, use the socketserver binary (included for Linux, SunOS and MacOS). To use a remote server, see the section on command line options for the GUI.
The socketserver can be executed from the command line using one of the following commands:
socketserver [-p] [-s]
socketserver -h
The available command line options are:
-h Prints a brief description of the command line options. -p Set port in server mode (default is 2350).</description></item><item><title>Tools Menu</title><link>/gui-reference/menu-bar/tools/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/menu-bar/tools/</guid><description>The tools menu contains a set of tools useful in the system edtior. The items are:
Check Syntax: checks if syntax and types are correct in the edited system. Any found errors and warnings are listed in the lower part of the drawing area of the system editor, and (when applicable) underlinded in the automata. Convert Syntax: assists in convering a system complying with the syntax used in UPPAAL 3.4 to the current syntax.</description></item><item><title>File Formats</title><link>/toolsandapi/file-formats/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/toolsandapi/file-formats/</guid><description>UPPAAL supports three file formats for models: XML, XTA and TA. XML and XTA files can be loaded and stored via the Open Project, Open System, Save System, and Save System As menus. When saving a file, the file type is determined by the file name extension used. Each format is explained in more details below.
Notice that the above mentioned file formats are mostly independent from the type of changes made to the syntax between UPPAAL 3.</description></item><item><title>Gantt Chart Panel</title><link>/gui-reference/concrete-simulator/gantt-chart/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/concrete-simulator/gantt-chart/</guid><description>The Gantt Chart panel is the middle rightmost panel of the simulator. It displays another view of the generated trace according to the Gantt Chart specification given in system definition.
In the Gantt Chart view, the horizontal axis represents the time span, and in the vertical axis the list of activities (usually some of the system processes) defined in the Gantt chart specification are listed. A vertical line is used to represent the current time (which corresponds to the one displayed in the Simulation Trace-combo box).</description></item><item><title>Message Sequence Chart</title><link>/gui-reference/symbolic-simulator/sequence-charts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/symbolic-simulator/sequence-charts/</guid><description>The Message Sequence Chart (MSC) panel is the lower rightmost panel of the simulator. It displays an MSC view of the generated trace (also displayed in the simulation control panel of the simulator).
In the MSC view there is a vertical line for each process, and a horizontal line for each synchronisation point. The process name of each vertical line is indicated in the upper part of the MSC panel. The node names shown on the vertical lines indicate the control location of the automaton.</description></item><item><title>Options Menu</title><link>/gui-reference/menu-bar/options/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/menu-bar/options/</guid><description>The options menu contains settings to control the behavior of the model-checker.
Search Order This option influences the order in which the state space is explored.
Breadth first Search the state space in breadth first search order. This is typically the most efficient option when the complete state space must be searched. When generating shortest or fastest traces, this is likely the best setting. Depth first Search the state space in depth first search order.</description></item><item><title>Priorities</title><link>/language-reference/system-description/priorities/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/language-reference/system-description/priorities/</guid><description>Given some priority order on the transitions, the intuition is that, at a given time-point, a transition is enabled only if no higher priority transition is enabled (see also Semantics.) We say that the higher priority transition blocks the lower priority transition.
Priorities can be assigned to the channels and processes of a system. The priority orders defined in the system are translated into a priority order on tau-transitions and synchronizing transitions.</description></item><item><title>Help Menu</title><link>/gui-reference/menu-bar/help/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/menu-bar/help/</guid><description>The help menu has two items: Help which opens a separate window showing the help pages, and About which opens a window showing the version number and information about the copyrights of UPPAAL.</description></item><item><title>Latex</title><link>/toolsandapi/latex/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/toolsandapi/latex/</guid><description>UPPAAL web site includes links to uppaal.sty file — style for typesetting documents in LaTeX.
UPPAAL Latex</description></item><item><title>Scope Rules</title><link>/language-reference/system-description/scope-rules/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/language-reference/system-description/scope-rules/</guid><description>The scope rules determine which element a name refers to in a given context. The context is either local (to a process template), or global (in a system description).
In a local context, the names are always referring to local declarations or formal parameters (if the name is locally defined), otherwise to a globally declared name.
In the global context, a name is always referring to a global declaration.
Note: There is only one name space in each context.</description></item><item><title>Semantics</title><link>/language-reference/system-description/semantics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/language-reference/system-description/semantics/</guid><description>In the following we give a pseudo-formal semantics for UPPAAL. The semantics defines a timed transition system (S, s0, →) describing the behaviour of a network of extended timed automata. The set of states S is defined as {(L, v) | v ⊨ Inv(L)}, where L is a location vector, v is a function (called a valuation) mapping integer variables and clocks to their values, and Inv is a function mapping locations and location vectors to invariants.</description></item><item><title>Symbolic Traces</title><link>/gui-reference/symbolic-simulator/symbolic-traces/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/gui-reference/symbolic-simulator/symbolic-traces/</guid><description>Since clocks range over the non-negative reals, timed automata can have infinitely many states (not to be confused with locations) and infinitely many traces. The simulator cannot visualize all these concrete traces. Instead it shows an infinite set of traces - a so called symbolic trace. Each symbolic state of a symbolic trace is a set of states and their delay successors described by a number of constraints on the clocks.</description></item></channel></rss>